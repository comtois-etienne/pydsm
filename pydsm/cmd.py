"""
Commands for processing geotiff files
"""


import webbrowser
import argparse
import time
import os
import sys

from skimage.draw import polygon
import imageio.v3 as iio
import numpy as np
import pandas as pd

import pydsm.geo as geo
import pydsm.nda as nda
import pydsm.shp as shp
import pydsm.obj as obj
import pydsm.rbh as rbh
import pydsm.utils as utils


def compute_ndsm(dsm_path: str, dtm_path: str, ndsm_path: str = None, correct_dtm: bool = False, capture_height: float = 60.0, resize: str = None):
    """
    Computes the nDSM from a DSM and DTM  

    :param dsm_path: str, path to the DSM (mandatory)  
    :param dtm_path: str, path to the DTM (mandatory)  
    :param ndsm_path: str, path to save the nDSM (optional)  
    :param correct_dtm: bool, removes extreme DTM values (optional)  
    :param capture_height: float, height of the drone during the capture (optional) (default: 60.0)  
    :param resize: str, path to the orthophoto to resize the DSM and DTM (optional)  
    :return: None (saves the nDSM to disk)  
    """
    print(f'* Opening the geotiffs')
    dsm = geo.open_geotiff(dsm_path)
    dtm = geo.open_geotiff(dtm_path)

    if resize:
        print(f'  Resizing DSM and DTM to the orthophoto shape')
        orthophoto = geo.open_geotiff(resize)
        shape_ortho = geo.get_shape(orthophoto)
        dsm = geo.resize_like(dsm, orthophoto) if geo.get_shape(dsm) != shape_ortho else dsm
        dtm = geo.resize_like(dtm, orthophoto) if geo.get_shape(dtm) != shape_ortho else dtm

    if geo.get_shape(dsm) != geo.get_shape(dtm):
        print(f'* Error: DSM and DTM have different shapes')
        print(f'  Consider resizing them to the orthophoto shape')
        return

    if correct_dtm:
        print(f'  Correcting DTM values')
        dtm = geo.correct_dtm(dtm)

    print(f'  Generating nDSM from \'{dsm_path}\' and \'{dtm_path}\'')
    capture_height = capture_height or 60.0
    ndsm = geo.to_ndsm(dsm, dtm, capture_height=capture_height)

    ndsm_path = ndsm_path or utils.append_file_to_path(utils.get_folder_path(dsm_path), 'ndsm.tif')
    geo.save_geotiff(ndsm, ndsm_path)
    print(f'  Saved to \'{ndsm_path}\'')


def display_epsg(path: str):
    """
    Displays the EPSG code of a file

    :param path: str, path to the file (mandatory)
    """
    ext = utils.get_extension(path)
    if ext == 'shp':
        epsg = shp.get_epsg(path)
        print(f'* Shapefile EPSG {epsg}')
    elif ext == 'tif':
        gdal = geo.open_geotiff(path)
        epsg = geo.get_epsg(gdal)
        print(f'* GeoTIFF EPSG {epsg}')
    else:
        epsg = None
        print('* Unsupported file format')


def reproject_geotiff(path: str, save_path: str = None, epsg=4326):
    """
    Reprojects a geotiff file to a new EPSG code  

    :param path: str, path to the geotiff file (mandatory)  
    :param save_path: str, path to save the reprojected file (optional)  
    :param epsg: int, new EPSG code (optional) (default: 4326)  
    :return: None (saves the reprojected file to disk)  
    """
    gdal = geo.open_geotiff(path)
    source_epsg = geo.get_epsg(gdal)
    print(f'* Reprojecting from EPSG:{source_epsg} to EPSG:{epsg}')
    reprojected = geo.reproject(gdal, epsg)

    save_path = save_path or f'{utils.remove_extension(path)}_{epsg}.tif'
    geo.save_geotiff(reprojected, save_path)
    print(f'  Saved to \'{save_path}\'')


def to_xyz(path: str, save_path: str = None):
    """
    Calculates the XYZ coordinates from a geotiff file (dtm, dsm, ndsm, etc.)
    Not recommended for large files. Use the geotiff directly instead.

    :param path: str, path to the geotiff file (mandatory)
    :param save_path: str, path to save the XYZ file (optional)
    :return: None (saves the XYZ file to disk as a compressed numpy file (.npz))
    """
    print(f'* Warning: The data generated by this command can be very large')
    print(f'* Consider querying the geotiff file directly instead')
    save_path = save_path or f'{utils.remove_extension(path)}.npz'
    gdal = geo.open_geotiff(path)
    epsg = geo.get_epsg(gdal)
    print(f'* Generating XYZ from EPSG {epsg}')
    xyz = geo.to_xyz(gdal)
    nda.write_numpy(save_path, data=xyz, metadata={'epsg': epsg})
    print(f'* Saved to \'{save_path}\'')


def to_cmap(path: str, cmap: str = None, save_path: str = None, downsample: int = None):
    """
    Converts a geotiff (dsm, dtm, ndsm) file to a colormap png

    :param path: str, path to the geotiff file (mandatory)
    :param cmap: str, colormap name (optional) (default: viridis)
    :param save_path: str, path to save the colormap (optional)
    :return: None (saves the colormap to disk)
    """
    downsample = downsample or 2
    downsample = int(downsample)
    cmap = cmap or 'viridis'
    save_path = save_path or f'{utils.remove_extension(path)}_{cmap}.jpg'
    print(f'* Opening \'{path}\'')
    gdal = geo.open_geotiff(path)
    array = geo.to_ndarray(gdal)

    if downsample > 1:
        print(f'  Downsampling by a factor of {downsample}')
        array = nda.downsample(array, downsample)

    print(f'  Generating {cmap} colormap from \'{path}\'')
    if cmap == 'rgb':
        array = nda.to_uint8(array)
    elif np.min(array) == 0.0:
        array = nda.to_cmap(array, cmap=cmap)
        array = nda.to_uint8(array)
    else:
        array = nda.dsm_to_cmap(array, cmap=cmap)
    
    array = array[..., :3]
    iio.imwrite(save_path, array)
    print(f'  Saved to \'{save_path}\'')


def overlay_values(path: str, y: int, x: int, h: int, w: int, cmap: str = None, save_path: str = None, region: bool = False, downscale: int = None):
    """
    Overlays the pixel values over each pixel of a cropped portion of an image

    :param path: str, path to the image file (mandatory)
    :param y: int, Y coordinate of the top left corner (mandatory)
    :param x: int, X coordinate of the top left corner (mandatory)
    :param h: int, height of the cropped image (mandatory)
    :param w: int, width of the cropped image (mandatory)
    :param cmap: str, colormap name (optional) (default: viridis)
    :param save_path: str, path of the croped region (optional)
    :param region: bool, overlay the region over the original image (optional)
    :param downscale: int, downscale factor for the image for performance reasons (optional)
    :return: None (saves the overlayed image to disk)
    """
    cmap = cmap or 'viridis'
    save_path = save_path or f'{utils.remove_extension(path)}_{cmap}_values.png'
    x2, y2 = x + w, y + h
    gdal = geo.open_geotiff(path)
    array = geo.to_ndarray(gdal)

    if downscale:
        array = nda.downsample(array, downscale)
        x, y, x2, y2 = x // downscale, y // downscale, x2 // downscale, y2 // downscale

    if region:
        print(f'* Generating {cmap} colormap of \'{path}\'')
        region_path = save_path.replace('_values.png', '_region.png')
        array_cmap = nda.to_cmap(array, cmap=cmap)
        array_cmap = nda.to_uint8(array_cmap)
        rr, cc = polygon([y, y, y2, y2], [x, x2, x2, x], shape=array.shape)
        array_cmap[rr, cc] = array_cmap[rr, cc] // 2
        iio.imwrite(region_path, array_cmap)
        print(f'* Saved to \'{region_path}\'')

    print(f'* Overlaying values of \'{path}\'')
    array = array[y:y2, x:x2]
    round_value = 0 if array.dtype == int else 3
    overlayed = nda.overlay_values(array, cmap=cmap, round_value=round_value)
    iio.imwrite(save_path, overlayed)
    print(f'* Saved to \'{save_path}\'')


def csv_to_shapefile(csv_path: str, shapefile_path: str = None, epsg: int = None):
    """
    Creates a shapefile from a CSV file

    :param csv_path: str, path to the CSV file (mandatory)
        contains a comment line with the EPSG code (optional)
        For epsg=4326, the longitude is 'x' and the latitude is 'y'
        csv example:
            ```
            #epsg=4326
            x,y
            0,0
            ```
    :param shapefile_path: str, path to save the shapefile (mandatory)
    :param epsg: int, EPSG code for the coordinate system (optional)
    """
    shp_path = shapefile_path or f'{utils.remove_extension(csv_path)}.shp'
    shp.save_from_csv(csv_path, shp_path, epsg=epsg)
    print(f'* Saved to \'{shapefile_path}\'')


def crop_geotiff(geotiff_path: str, shapefile_path: str, save_path: str = None, dilate: float = 15.0):
    """
    Crop a geotiff file with a shapefile

    :param geotiff_path: str, path to the geotiff file (mandatory)
    :param shapefile_path: str, path to the shapefile (mandatory)
    :param save_path: str, path to save the cropped geotiff (optional)
    """
    path = utils.get_folder_path(geotiff_path)
    uuid = utils.remove_extension(utils.get_filename(shapefile_path))
    name = utils.remove_extension(utils.get_filename(geotiff_path))

    if save_path:
        if utils.get_extension(save_path) == '':
            save_path = utils.append_file_to_path(save_path, f'{uuid}_{name}.tif')
    else: 
        save_path = utils.append_file_to_path(path, f'{uuid}_{name}.tif')

    dilate = dilate or 15.0
    gdal = geo.open_geotiff(geotiff_path)
    cropped = geo.crop_from_shapefile(gdal, shapefile_path, dilate_size=dilate)
    geo.save_geotiff(cropped, save_path)
    print(f'* Saved to \'{save_path}\'')


def extract_by_zone(geotiff_paths: list,
                    geotiff_base_path: str = None,
                    save_directory: str = None,
                    no_crop: bool = False,
                    dilate: float = 15.0,
                    safe_zone: float = 20.0,
                    sample_size: int = 3,
                    translate_x: float = 0.0,
                    translate_y: float = 0.0,
                    translate_file: str = None):
    """
    Extracts zones surrounded by streets from a geotiff file
    Crops the geotiff file to the zones if --no-crop is not set and --crop-geotiff is not set

    :param geotiff_paths: str, path to the geotiff file (mandatory)
    :param geotiff_base_path: str, path to the folder that contains all the geotiff files (optional)
    :param save_directory: str, path to save the zones (shapefile, geotiff) (optional)
    :param no_crop: bool, do not crop the geotiff to the zones (optional)
    :param dilate: float, dilation factor around the zones (optional) (default: 15.0m)
    :param safe_zone: float, the zone is only kept if there is at lest X meters around (optional) (default: 20.0m)
    :param sample_size: int, sample size (number of seeds) to find the zones (optional) (default: 3 (3x3))
    :param translate_x: float, X translation (East to West) (optional)
    :param translate_y: float, Y translation (South to North) (optional)
    :param translate_file: str, path that contains the translation values (optional)
    :return: None (saves the zones to disk as geotiffs)
    """
    if geotiff_base_path:
        geotiff_paths = [utils.append_file_to_path(geotiff_base_path, geotiff_path) for geotiff_path in geotiff_paths]

    save_folder = save_directory or utils.get_folder_path(geotiff_paths[0])
    sample_size = sample_size or 3
    safe_zone = safe_zone or 20.0
    dilate = dilate or 15.0
    x = translate_x or 0.0
    y = translate_y or 0.0

    if translate_file:
        df = pd.read_csv(translate_file)
        x = df['x'][0]
        y = df['y'][0]

    print(f'* Extracting zones from \'{geotiff_paths[0]}\'')
    uuids = geo.extract_zones(
        geotiff_paths[0], 
        save_folder, 
        sample_size=sample_size, 
        safe_zone=safe_zone
    )
    print(f'* Saved to {save_folder}')

    geotiff_paths = [] if no_crop else geotiff_paths
    for geotiff_path in geotiff_paths:
        print(f'* Cropping \'{geotiff_path}\'')
        geotiff_file = geo.open_geotiff(geotiff_path)

        if x or y:
            print(f'  Translating by {x}m X and {y}m Y')
            geotiff_file = geo.translation(geotiff_file, (x, y))

        name = utils.get_filename(geotiff_path)
        name = utils.remove_extension(name)

        for uuid in uuids:
            save_path = utils.append_file_to_path(save_folder, uuid)
            file_path = f'{save_path}_{name}.tif'
            croped_ortho = geo.crop_from_shapefile(geotiff_file, f'{save_path}.shp', dilate_size=dilate)
            geo.save_geotiff(croped_ortho, file_path)
            print(f'  Saved to \'{file_path}\'')


def display_geotiff_info(path: str):
    """
    Displays information about a geotiff file

    :param path: str, path to the geotiff file (mandatory)
    :return: None (displays the information to the console)
    """
    gdal = geo.open_geotiff(path)
    print(f'* Information about \'{path}\'')

    print(f'* Raster info:')
    print(f'  Shape: {geo.get_shape(gdal)}')

    dtype = geo.get_dtype(gdal)
    if dtype in utils.DTYPE_TO_NP.keys():
        print(f'  Dtype unit: {utils.DTYPE_TO_NP[dtype].__name__}')
    print(f'  Dtype number: {dtype}')

    print(f'* Geo info:')
    print(f'  EPSG:{geo.get_epsg(gdal)}')
    print(f'  Origin: {geo.get_origin(gdal)}')
    print(f'  Center: {geo.get_center(gdal)}')
    print(f'  Size: {geo.get_size(gdal)} m')
    print(f'  Scale: {geo.get_scales(gdal)[0]} m/px')


def resize_geotiff_like(geotiff_path: str, geotiff_like_path: str, save_path: str = None):
    """
    Resize a geotiff file  
    `Warning` the resized geotiff will break the georeferencing

    :param geotiff_path: str, path to the geotiff file (mandatory)
    :param geotiff_like_path: str, path to the geotiff file to get the shape from (mandatory)
    :param save_path: str, path to save the resized (optional)
    :return: None (saves the resized geotiff to disk)
    """
    save_path = save_path or f'{utils.remove_extension(geotiff_path)}_resized.tif' 
    gdal = geo.open_geotiff(geotiff_path)
    gdal_like = geo.open_geotiff(geotiff_like_path)
    print(f'* Resizing from {geo.get_shape(gdal)} to {geo.get_shape(gdal_like)}')
    resized = geo.resize_like(gdal, gdal_like)
    geo.save_geotiff(resized, save_path)
    print(f'* Saved to \'{save_path}\'')


def rescale_geotiff(geotiff_path: str, scale: float, save_path: str = None):
    """
    Rescale a geotiff file from its original scale to a new scale

    :param geotiff_path: str, path to the geotiff file (mandatory)
    :param scale: float, scale factor in meters/px (mandatory)
    :param save_path: str, path to save the rescaled (optional)
    :return: None (saves the rescaled geotiff to disk)
    """
    save_path = save_path or f'{utils.remove_extension(geotiff_path)}_rescale.tif'
    gdal = geo.open_geotiff(geotiff_path)
    print(f'* Rescaling from {geo.get_scales(gdal)[0]}m/px to {scale}m/px')
    rescaled = geo.rescale(gdal, scale)
    geo.save_geotiff(rescaled, save_path)
    print(f'* Saved to \'{save_path}\'')


def translate_geotiff(geotiff_path: str, x: float, y: float, save_path: str = None):
    """
    2D translation of a geotiff file

    :param geotiff_path: str, path to the geotiff file (mandatory)
    :param x: float, X translation (mandatory)
    :param y: float, Y translation (mandatory)
    :param save_path: str, path to save the translated geotiff (optional)
    :return: None (saves the translated geotiff to disk)
    """
    save_path = save_path or f'{utils.remove_extension(geotiff_path)}_translated.tif'
    gdal = geo.open_geotiff(geotiff_path)

    if geo.get_epsg(gdal) == utils.CRS_GPS:
        print(f'* Warning: The translation in meters does not work with GPS coordinates')
        print(f'  Consider reprojecting the geotiff to a Cartesian coordinate system')
        return

    print(f'* Translating \'{geotiff_path}\' by {x}m X and {y}m Y')
    translated = geo.translation(gdal, (x, y))
    geo.save_geotiff(translated, save_path)
    print(f'  Saved to \'{save_path}\'')


def geotiff_registration(
        geotiff_path: str, 
        save_path: str = None, 
        translate: bool = True, 
        registration_path: str = None, 
        layer: str = None
    ):
    """
    Register a geotiff file onto the osm map using a translation  
    The geotiff file is translated to the selected point on the map  

    :param geotiff_path: str, path to the geotiff file (mandatory)
    :param save_path: str, path to save the registered geotiff (optional)
    :param translate: bool, translate the geotiff to the selected point (False will simply save the translation values) (optional)
    :param registration_path: str, path to save the translation values (optional)
    :param layer: str, layer of the map (osm, streets, satellite) (optional) (default: osm)
    :return: None (saves the registered geotiff to disk and the translation values to a csv file)
    """
    layer = layer or 'satellite'
    csv_path = registration_path or utils.append_file_to_path(utils.get_folder_path(geotiff_path), 'translate.csv')
    save_path = save_path or f'{utils.remove_extension(geotiff_path)}_registered.tif'
    geotiff = geo.open_geotiff(geotiff_path)
    url = utils.epsgio_link_from_coord(geo.get_center(geotiff), geo.get_epsg(geotiff), layer=layer)

    print(f'* Registering \'{geotiff_path}\' onto the OSM map')
    print(f'  Please select a point on the map to register the geotiff')
    print(f'  Opening {url} in 3s...', end=' ')
    time.sleep(1)
    print('2s...', end=' ')
    time.sleep(1)
    print('1s...')
    time.sleep(1)
    webbrowser.open(url)

    link = input('* Paste the link of the map here and press enter: ')
    osm_coord = utils.epsgio_link_to_coord(link)
    print(f'  The selected coordinate is {osm_coord}')

    print(f'* Please select the same point on the geotiff')
    geo_coord = geo.get_coordinate_on_click(geotiff)
    x = round(osm_coord[0] - geo_coord[0], 1)
    y = round(osm_coord[1] - geo_coord[1], 1)
    print(f'  Translation values: {x} {y} (x, y)')

    df = pd.DataFrame({'x': [x], 'y': [y]})
    df.to_csv(csv_path, index=False)
    print(f'  Saved to \'{csv_path}\'')

    if translate:
        print(f'* Translating {geotiff_path} by {x}m X and {y}m Y')
        translated = geo.translation(geotiff, (x, y))
        geo.save_geotiff(translated, save_path)
        print(f'  Saved to \'{save_path}\'')


def generate_rbh_wavefront(
        masks_path: str, 
        ndsm_path: str, 
        dtm_path: str, 
        ortho_path: str,
        save_dir: str = None, 
        elevation_offset: float = False, 
        verbose: bool = False
    ):
    """
    Generates geometry objects for trees from the masks and the ndsm.  
    The triangulated rhombicuboctahedron (RBH) geometry is used to represent the trees. 
    The dtm is used to get the ground level of the trees.
    The orthophoto is used to get the rejection region of the trees. 

    :param masks_path: str, path to the instance masks (mandatory)
    :param ndsm_path: str, path to the nDSM (mandatory)
    :param dtm_path: str, path to the DTM (mandatory)
    :param ortho_path: str, path to the orthophoto (mandatory)
    :param save_dir: str, path to directory to save the wavefront and metadata (optional) (default: current directory)
    :param elevation_offset: float, elevation offset for the trees instead of relying on the DTM (optional) (default: False)
    :param verbose: bool, verbose mode to display the whole process (optional) (default: False)
    :return: None (saves the wavefront and metadata to disk)
    """
    if not os.path.exists(save_dir):
        print(f'* Creating directory \'{save_dir}\'')
        os.makedirs(save_dir)

    print(f'* Generating wavefront objects from masks in {masks_path}')
    instance_masks = nda.read_numpy(masks_path, npz_format='napari')
    ndsm = geo.open_geotiff(ndsm_path)
    rejection_region = geo.get_outside_mask(geo.open_geotiff(ortho_path))
    dtm = geo.open_geotiff(dtm_path)
    uuid = os.path.basename(ortho_path).split('_')[0]

    wavefront_objects, objects_metadata = rbh.tree_modeling(
        ndsm=ndsm,
        dtm=dtm,
        instance_masks=instance_masks,
        rejection_region=rejection_region,
        uuid=uuid,
        elevation_offset=elevation_offset,
        verbose=verbose,
    )

    obj_path = utils.append_file_to_path(save_dir, f'{uuid}_trees.obj')
    meta_path = utils.append_file_to_path(save_dir, f'{uuid}_trees_metadata.json')
    
    obj.write_wavefront(wavefront_objects, file_path=obj_path, swap_yz=False, precision=3)
    print(f'* Saved to \'{obj_path}\'')

    utils.write_dict_as_json(objects_metadata, file_path=meta_path)
    print(f'* Saved to \'{meta_path}\'')


def extract_tiles(orthophoto_path: str, ndsm_path: str, tiles_dir: str, date: str, tile_size: int = None, scale: float = None, verbose: bool = True) -> None:
    """
    Extract valid tiles from an orthophoto and NDSM, and save them to a directory.
    Tiles name : `{tile_size}_{x}_{y} ({date}) ({distance from border}m).tif`
        Bigger distances from the border should indicate better quality tiles.

    :param orthophoto_path: path to the orthophoto geotiff file
    :param ndsm_path: path to the NDSM geotiff file
    :param tiles_dir: directory to save the extracted tiles (must contain a 'orthophoto' and 'ndsm' subdirectory)
    :param date: date of the tiles (used in the naming convention of the saved tiles)
    :param tile_size: size of the tiles in meters (default is 50m)
    :param scale: scale in meters per pixel to resize the tiles (default is 0.02)
    :param verbose: whether to display the tile grid (default is True)
    :return: None (saves the tiles to the directory)    
    """
    tile_size = tile_size or 50  # default tile size in meters
    scale = scale or 0.02  # default scale in meters per pixel
    
    orthophoto = geo.open_geotiff(orthophoto_path)
    ndsm = geo.open_geotiff(ndsm_path)

    print(f'* Extracting tiles from \'{orthophoto_path}\'')
    tiles_coordinates, tile_distances = geo.get_tiles_coordinates(orthophoto, tile_size, scale)

    if verbose:
        geo.display_tile_grid(orthophoto, tile_size, tiles_coordinates=tiles_coordinates)

    print(f'* Cropping orthophoto into tiles')
    array = geo.to_ndarray(orthophoto)
    ortho_dir = os.path.join(tiles_dir, 'orthophoto')
    for i in range(len(tiles_coordinates)):
        tile = geo.crop_into_tile(orthophoto, tiles_coordinates[i], tile_size, scale, array)
        geo.save_tile(tile, tile_distances[i], ortho_dir, date)
    print(f'  Tiles saved to \'{ortho_dir}\'')

    print(f'* Cropping NDSM into tiles')
    array = geo.to_ndarray(ndsm)
    ndsm_dir = os.path.join(tiles_dir, 'ndsm')
    for i in range(len(tiles_coordinates)):
        tile = geo.crop_into_tile(ndsm, tiles_coordinates[i], tile_size, scale, array)
        geo.save_tile(tile, tile_distances[i], ndsm_dir, date)
    print(f'  Tiles saved to \'{ndsm_dir}\'')


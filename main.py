#!/opt/anaconda3/envs/geo/bin/python
import argparse
import time
import os
import sys

from skimage.draw import polygon
import imageio.v3 as iio
import numpy as np

import pydsm.geo as geo
import pydsm.nda as nda
import pydsm.shp as shp
import pydsm.utils as utils


# COMMANDS

def ndsm(args):
    """
    Computes the nDSM from a DSM and DTM
    :param args.dsm_path: str, path to the DSM (mandatory)
    :param args.dtm_path: str, path to the DTM (mandatory)
    :param args.ndsm_path: str, path to save the nDSM (mandatory)
    :param args.correct_dtm: bool, correct extreme DTM values (optional)
    :param args.capture_height: float, height of the drone during the capture (optional) (default: 60.0)
    :return: None (saves the nDSM to disk)
    """
    dsm = geo.open_geotiff(args.dsm_path)
    dtm = geo.open_geotiff(args.dtm_path)
    dtm = geo.correct_dtm(dtm) if args.correct_dtm else dtm
    capture_height = args.capture_height or 60.0
    ndsm = geo.to_ndsm(dsm, dtm, capture_height=capture_height)
    geo.save_geotiff(ndsm, args.ndsm_path)
    print(f'* Saved to {args.ndsm_path}')


def epsg(args):
    """
    Displays the EPSG code of a file
    :param args.path: str, path to the file (mandatory)
    """
    ext = utils.get_extension(args.path)
    if ext == 'shp':
        epsg = shp.get_epsg(args.path)
        print(f'* Shapefile EPSG {epsg}')
    elif ext == 'tif':
        gdal = geo.open_geotiff(args.path)
        epsg = geo.get_epsg(gdal)
        print(f'* GeoTIFF EPSG {epsg}')
    else:
        epsg = None
        print('* Unknown file format')


def reproject(args):
    """
    Reprojects a geotiff file to a new EPSG code
    :param args.path: str, path to the geotiff file (mandatory)
    :param args.save_path: str, path to save the reprojected file (optional)
    :param args.epsg: int, new EPSG code (optional) (default: 4326)
    :return: None (saves the reprojected file to disk)
    """
    epsg = args.epsg or 4326
    save_path = args.save_path or f'{utils.remove_extension(args.path)}_{epsg}.tif'

    gdal = geo.open_geotiff(args.path)
    source_epsg = geo.get_epsg(gdal)
    print(f'* Reprojecting to EPSG {epsg} from EPSG {source_epsg}')
    reprojected = geo.reproject(gdal, epsg)
    geo.save_geotiff(reprojected, save_path)
    print(f'* Saved to {save_path}')


def xyz(args):
    """
    Calculates the XYZ coordinates from a geotiff file (dtm, dsm, ndsm, etc.)
    Not recommended for large files. Use the geotiff directly instead.
    :param args.path: str, path to the geotiff file (mandatory)
    :param args.save_path: str, path to save the XYZ file (optional)
    :return: None (saves the XYZ file to disk as a compressed numpy file (.npz))
    """
    print(f'* Warning: The data generated by this command can be very large')
    print(f'* Consider querying the geotiff file directly instead')
    save_path = args.save_path or f'{utils.remove_extension(args.path)}.npz'
    gdal = geo.open_geotiff(args.path)
    epsg = geo.get_epsg(gdal)
    print(f'* Generating XYZ from EPSG {epsg}')
    xyz = geo.to_xyz(gdal)
    nda.write_numpy(save_path, data=xyz, metadata={'epsg': epsg})
    print(f'* Saved to {save_path}')


def cmap(args):
    """
    Converts a geotiff (dsm, dtm, ndsm) file to a colormap png
    :param args.path: str, path to the geotiff file (mandatory)
    :param args.cmap: str, colormap name (optional) (default: viridis)
    :param args.save_path: str, path to save the colormap (optional)
    :return: None (saves the colormap to disk)
    """
    cmap = args.cmap or 'viridis'
    save_path = args.save_path or f'{utils.remove_extension(args.path)}_{cmap}.png'
    gdal = geo.open_geotiff(args.path)
    print(f'* Generating {cmap} colormap from {args.path}')
    array = geo.to_ndarray(gdal)
    if np.min(array) == 0.0:
        array_cmap = nda.to_cmap(array, cmap=cmap)
        array_cmap = nda.to_uint8(array_cmap)
    else:
        array_cmap = nda.dsm_to_cmap(array, cmap=cmap)
    iio.imwrite(save_path, array_cmap)
    print(f'* Saved to {save_path}')


def values(args):
    """
    Overlays the pixel values over each pixel of a cropped portion of an image
    :param args.path: str, path to the image file (mandatory)
    :param args.y: int, Y coordinate of the top left corner (mandatory)
    :param args.x: int, X coordinate of the top left corner (mandatory)
    :param args.h: int, height of the cropped image (mandatory)
    :param args.w: int, width of the cropped image (mandatory)
    :param args.cmap: str, colormap name (optional) (default: viridis)
    :param args.save_path: str, path of the croped region (optional)
    :param args.region: bool, overlay the region over the original image (optional)
    :param args.downscale: int, downscale factor for the image for performance reasons (optional)
    """
    cmap = args.cmap or 'viridis'
    save_path = args.save_path or f'{utils.remove_extension(args.path)}_{cmap}_values.png'
    x, y, h, w = args.x, args.y, args.h, args.w
    x2, y2 = x + w, y + h
    gdal = geo.open_geotiff(args.path)
    array = geo.to_ndarray(gdal)

    if args.downscale:
        factor = args.downscale
        array = array[::factor, ::factor]
        x, y, x2, y2 = x // factor, y // factor, x2 // factor, y2 // factor

    if args.region:
        print(f'* Generating {cmap} colormap of {args.path}')
        region_path = save_path.replace('_values.png', '_region.png')
        array_cmap = nda.to_cmap(array, cmap=cmap)
        array_cmap = nda.to_uint8(array_cmap)
        rr, cc = polygon([y, y, y2, y2], [x, x2, x2, x], shape=array.shape)
        array_cmap[rr, cc] = array_cmap[rr, cc] // 2
        iio.imwrite(region_path, array_cmap)
        print(f'* Saved to {region_path}')

    print(f'* Overlaying values of {args.path}')
    array = array[y:y2, x:x2]
    round_value = 0 if array.dtype == int else 3
    overlayed = nda.overlay_values(array, cmap=cmap, round_value=round_value)
    iio.imwrite(save_path, overlayed)
    print(f'* Saved to {save_path}')


def shapefile(args):
    """
    Creates a shapefile from a CSV file
    :param args.csv_path: str, path to the CSV file (mandatory)
        contains a comment line with the EPSG code (optional)
        For epsg=4326, the longitude is 'x' and the latitude is 'y'
        csv example:
            ```
            #epsg=4326
            x,y
            0,0
            ```
    :param args.shapefile_path: str, path to save the shapefile (mandatory)
    :param args.epsg: int, EPSG code for the coordinate system (optional)
    """
    shp_path = args.shapefile_path or f'{utils.remove_extension(args.csv_path)}.shp'
    shp.save_from_csv(args.csv_path, shp_path, epsg=args.epsg)
    print(f'* Saved to {args.shapefile_path}')


def crop(args):
    """
    Crop a geotiff file with a shapefile
    :param args.geotiff_path: str, path to the geotiff file (mandatory)
    :param args.shapefile_path: str, path to the shapefile (mandatory)
    :param args.save_path: str, path to save the cropped geotiff (optional)
    """
    save_path = args.save_path or f'{utils.remove_extension(args.geotiff_path)}_crop.tif'
    dilate = args.dilate or 5.0
    gdal = geo.open_geotiff(args.geotiff_path)
    cropped = geo.crop_from_shapefile(gdal, args.shapefile_path, dilate_size=dilate)
    geo.save_geotiff(cropped, save_path)
    print(f'* Saved to {save_path}')


def zones(args):
    """
    Extracts zones surrounded by streets from a geotiff file
    Crops the geotiff file to the zones if --no-crop is not set and --crop-geotiff is not set

    :param args.geotiff_paths: str, path to the geotiff file (mandatory)
    :param args.save_directory: str, path to save the zones (shapefile, geotiff) (optional)
    :param args.no_crop: bool, do not crop the geotiff to the zones (optional)
    :param args.dilate: float, dilation factor around the zones (optional) (default: 5.0m)
    :param args.safe_zone: float, the zone is only kept if there is at lest X meters around (optional) (default: 10.0m)
    :param args.sample_size: int, sample size (number of seeds) to find the zones (optional) (default: 3 (3x3))
    """
    print(args)

    save_folder = args.save_directory or utils.get_folder_path(args.geotiff_paths[0])
    sample_size = args.sample_size or 3
    safe_zone = args.safe_zone or 10.0
    dilate = args.dilate or 5.0

    print(f'* Extracting zones from {args.geotiff_paths[0]}')
    uuids = geo.extract_zones(
        args.geotiff_paths[0], 
        save_folder, 
        sample_size=sample_size, 
        safe_zone=safe_zone
    )
    print(f'* Saved to {save_folder}')

    geotiff_paths = [] if args.no_crop else args.geotiff_paths
    for geotiff_path in geotiff_paths:
        print(f'* Cropping {geotiff_path}')
        geotiff_file = geo.open_geotiff(geotiff_path)
        name = utils.get_filename(geotiff_path)
        name = utils.remove_extension(name)

        for uuid in uuids:
            save_path = utils.append_file_to_path(save_folder, uuid)
            file_path = f'{save_path}_{name}.tif'
            croped_ortho = geo.crop_from_shapefile(geotiff_file, f'{save_path}.shp', dilate_size=dilate)
            geo.save_geotiff(croped_ortho, file_path)
            print(f'  Saved to {file_path}')


# GENERAL COMMANDS

def silent_mode(args):
    if args.silent:
        sys.stdout = open(os.devnull, 'w')


def time_mode(args, t0):
    sys.stdout = sys.__stdout__
    t1 = time.time()
    if args.time:
        print(f'* Elapsed time: {t1 - t0:.2f} seconds')


# ARGUMENT PARSER SETUP

COMMANDS = {
    'ndsm': ndsm,
    'epsg': epsg,
    'reproject': reproject,
    'xyz': xyz,
    'cmap': cmap,
    'values': values,
    'shapefile': shapefile,
    'crop': crop,
    'zones': zones,
}


def parser_setup():
    parser = argparse.ArgumentParser(description='PyDSM : DSM, DTM, nDSM & Ortophoto tools')
    parser.add_argument("--silent", action="store_true", help="Silent mode")
    parser.add_argument("--time", action="store_true", help="Displays time elapsed")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # ndsm command
    parser_ndsm = subparsers.add_parser("ndsm", help="Generate a nDSM from a DSM and DTM")
    parser_ndsm.add_argument("dsm_path", type=str, help="Path to the DSM")
    parser_ndsm.add_argument("dtm_path", type=str, help="Path to the DTM")
    parser_ndsm.add_argument("ndsm_path", type=str, help="Path to the output nDSM")
    parser_ndsm.add_argument("--correct-dtm", action="store_true", help="Correct extreme DTM values")
    parser_ndsm.add_argument("--capture-height", type=float, help="Height of the drone during the capture")

    # epsg command
    parser_epsg = subparsers.add_parser("epsg", help="Get the EPSG code of a file (GeoTIFF or Shapefile)")
    parser_epsg.add_argument("path", type=str, help="Path to the file")

    # reproject command
    parser_reproject = subparsers.add_parser("reproject", help="Reproject a file to a new EPSG code")
    parser_reproject.add_argument("path", type=str, help="Path to the geotiff file")
    parser_reproject.add_argument("--save-path", type=str, help="Path to save the reprojected file")
    parser_reproject.add_argument("--epsg", type=int, help="New EPSG code")

    # xyz command
    parser_xyz = subparsers.add_parser("xyz", help="Generate a XYZ file from a geotiff as a compressed numpy (.npz)")
    parser_xyz.add_argument("path", type=str, help="Path to the geotiff file")
    parser_xyz.add_argument("--save-path", type=str, help="Path to save the XYZ file")

    # cmap command
    parser_cmap = subparsers.add_parser("cmap", help="Generate a colormap png from a geotiff")
    parser_cmap.add_argument("path", type=str, help="Path to the geotiff file")
    parser_cmap.add_argument("--cmap", type=str, help="Colormap name (default: viridis)")
    parser_cmap.add_argument("--save-path", type=str, help="Path to save the colormap")

    # values command
    parser_values = subparsers.add_parser("values", help="Displays the values of a cropped image file (GeoTIFF or PNG)")
    parser_values.add_argument("path", type=str, help="Path to the image file")
    parser_values.add_argument("y", type=int, help="Y coordinate of the top left corner")
    parser_values.add_argument("x", type=int, help="X coordinate of the top left corner")
    parser_values.add_argument("h", type=int, help="height of the cropped image")
    parser_values.add_argument("w", type=int, help="width of the cropped image")
    parser_values.add_argument("--cmap", type=str, help="Colormap name (default: viridis)")
    parser_values.add_argument("--save-path", type=str, help="Path to save the values")
    parser_values.add_argument("--region", action="store_true", help="Overlay the region on the original image")
    parser_values.add_argument("--downscale", type=int, help="Downscale factor for the image")

    # create shapefile from csv
    parser_shp_create = subparsers.add_parser("shapefile", help="Create a shapefile from a CSV file")
    parser_shp_create.add_argument("csv_path", type=str, help="Path to the CSV file")
    parser_shp_create.add_argument("--shapefile_path", type=str, help="Path to save the shapefile")
    parser_shp_create.add_argument("--epsg", type=int, help="EPSG code for the coordinate system")

    # crop geotiff with shapefile
    crop_parser = subparsers.add_parser("crop", help="Crop a geotiff file with a shapefile")
    crop_parser.add_argument("geotiff_path", type=str, help="Path to the geotiff file")
    crop_parser.add_argument("shapefile_path", type=str, help="Path to the shapefile")
    crop_parser.add_argument("--dilate", type=float, help="Dilation factor around the shapefile (default: 5.0m)")
    crop_parser.add_argument("--save-path", type=str, help="Path to save the cropped geotiff")

    # zones command
    zones_parser = subparsers.add_parser("zones", help="Crops a geotiff into zones surrounded by streets")
    zones_parser.add_argument("geotiff_paths", nargs='+', help="Path to the geotiff files. The first one is used to find the zones.")
    zones_parser.add_argument("--save-directory", type=str, help="Path to save the zones (shapefile, geotiff)")
    zones_parser.add_argument("--no-crop", action="store_true", help="Do not crop the geotiff to the zones")
    zones_parser.add_argument("--dilate", type=float, help="Dilation factor around the zones (default: 5.0m)")
    zones_parser.add_argument("--safe-zone", type=float, help="The zone is only kept if there is at least X meters around it (default: 10.0m)")
    zones_parser.add_argument("--sample-size", type=int, help="Sample size (number of seeds) to find the zones (default: 3 (3x3))")

    return parser


def main():
    t0 = time.time()
    parser = parser_setup()
    args = parser.parse_args()
    silent_mode(args)
    COMMANDS[args.command](args)
    time_mode(args, t0)


if __name__ == "__main__":
    main()


#!/opt/anaconda3/envs/geo/bin/python
import argparse
import time
import os
import sys

from skimage.draw import polygon
import imageio.v3 as iio
import numpy as np

import pydsm.geo as geo
import pydsm.nda as nda
import pydsm.shp as shp


"""
- todo : path resolver : './data/dtm.tif'.split('.')[0] -> '' (to be fixed to './data/dtm')

"""


# COMMANDS

def ndsm(args):
    """
    Computes the nDSM from a DSM and DTM
    :param args.dsm_path: str, path to the DSM (mandatory)
    :param args.dtm_path: str, path to the DTM (mandatory)
    :param args.ndsm_path: str, path to save the nDSM (mandatory)
    :param args.correct_dtm: bool, correct extreme DTM values (optional)
    :param args.capture_height: float, height of the drone during the capture (optional) (default: 60.0)
    :return: None (saves the nDSM to disk)
    """
    dsm = geo.open_geotiff(args.dsm_path)
    dtm = geo.open_geotiff(args.dtm_path)
    dtm = geo.correct_dtm(dtm) if args.correct_dtm else dtm
    capture_height = args.capture_height if args.capture_height else 60.0
    ndsm = geo.to_ndsm(dsm, dtm, capture_height=capture_height)
    geo.save_geotiff(ndsm, args.ndsm_path)
    print(f'* Saved to {args.ndsm_path}')


def epsg(args):
    """
    Displays the EPSG code of a file
    :param args.path: str, path to the file (mandatory)
    """
    ext = args.path.split('.')[-1]
    if ext == 'shp':
        epsg = shp.get_epsg(args.path)
        print(f'* Shapefile EPSG {epsg}')
    elif ext == 'tif':
        gdal = geo.open_geotiff(args.path)
        epsg = geo.get_epsg(gdal)
        print(f'* GeoTIFF EPSG {epsg}')
    else:
        epsg = None
        print('* Unknown file format')


def reproject(args):
    """
    Reprojects a geotiff file to a new EPSG code
    :param args.path: str, path to the geotiff file (mandatory)
    :param args.save_path: str, path to save the reprojected file (optional)
    :param args.epsg: int, new EPSG code (optional) (default: 4326)
    :return: None (saves the reprojected file to disk)
    """
    epsg = args.epsg if args.epsg else 4326
    save_path = args.save_path if args.save_path else args.path.split('.')[0] + f'_{epsg}.tif'

    gdal = geo.open_geotiff(args.path)
    source_epsg = geo.get_epsg(gdal)
    print(f'* Reprojecting to EPSG {epsg} from EPSG {source_epsg}')
    reprojected = geo.reproject(gdal, epsg)
    geo.save_geotiff(reprojected, save_path)
    print(f'* Saved to {save_path}')


def xyz(args):
    """
    Calculates the XYZ coordinates from a geotiff file (dtm, dsm, ndsm, etc.)
    Not recommended for large files. Use the geotiff directly instead.
    :param args.path: str, path to the geotiff file (mandatory)
    :param args.save_path: str, path to save the XYZ file (optional)
    :return: None (saves the XYZ file to disk as a compressed numpy file (.npz))
    """
    print(f'* Warning: The data generated by this command can be very large')
    print(f'* Consider querying the geotiff file directly instead')
    save_path = args.save_path if args.save_path else args.path.split('.')[0] + '.npz'
    gdal = geo.open_geotiff(args.path)
    epsg = geo.get_epsg(gdal)
    print(f'* Generating XYZ from EPSG {epsg}')
    xyz = geo.to_xyz(gdal)
    nda.write_numpy(save_path, data=xyz, metadata={'epsg': epsg})
    print(f'* Saved to {save_path}')


def cmap(args):
    """
    Converts a geotiff (dsm, dtm, ndsm) file to a colormap png
    :param args.path: str, path to the geotiff file (mandatory)
    :param args.cmap: str, colormap name (optional) (default: viridis)
    :param args.save_path: str, path to save the colormap (optional)
    :return: None (saves the colormap to disk)
    """
    cmap = args.cmap if args.cmap else 'viridis'
    save_path = args.save_path if args.save_path else args.path.split('.')[0] + f'_{cmap}.png'
    gdal = geo.open_geotiff(args.path)
    print(f'* Generating {cmap} colormap from {args.path}')
    array = geo.to_ndarray(gdal)
    if np.min(array) == 0.0:
        array_cmap = nda.to_cmap(array, cmap=cmap)
        array_cmap = nda.to_uint8(array_cmap)
    else:
        array_cmap = nda.dsm_to_cmap(array, cmap=cmap)
    iio.imwrite(save_path, array_cmap)
    print(f'* Saved to {save_path}')


def values(args):
    """
    Overlays the pixel values over each pixel of a cropped portion of an image
    :param args.path: str, path to the image file (mandatory)
    :param args.y: int, Y coordinate of the top left corner (mandatory)
    :param args.x: int, X coordinate of the top left corner (mandatory)
    :param args.h: int, height of the cropped image (mandatory)
    :param args.w: int, width of the cropped image (mandatory)
    :param args.cmap: str, colormap name (optional) (default: viridis)
    :param args.save_path: str, path of the croped region (optional)
    :param args.region: bool, overlay the region over the original image (optional)
    :param args.downscale: int, downscale factor for the image for performance reasons (optional)
    """
    cmap = args.cmap if args.cmap else 'viridis'
    save_path = args.save_path if args.save_path else args.path.split('.')[0] + f'_{cmap}_values.png'
    x, y, h, w = args.x, args.y, args.h, args.w
    x2, y2 = x + w, y + h
    gdal = geo.open_geotiff(args.path)
    array = geo.to_ndarray(gdal)

    if args.downscale:
        factor = args.downscale
        array = array[::factor, ::factor]
        x, y, x2, y2 = x // factor, y // factor, x2 // factor, y2 // factor

    if args.region:
        print(f'* Generating {cmap} colormap of {args.path}')
        region_path = save_path.replace('_values.png', '_region.png')
        array_cmap = nda.to_cmap(array, cmap=cmap)
        array_cmap = nda.to_uint8(array_cmap)
        rr, cc = polygon([y, y, y2, y2], [x, x2, x2, x], shape=array.shape)
        array_cmap[rr, cc] = array_cmap[rr, cc] // 2
        iio.imwrite(region_path, array_cmap)
        print(f'* Saved to {region_path}')

    print(f'* Overlaying values of {args.path}')
    array = array[y:y2, x:x2]
    round_value = 0 if array.dtype == int else 3
    overlayed = nda.overlay_values(array, cmap=cmap, round_value=round_value)
    iio.imwrite(save_path, overlayed)
    print(f'* Saved to {save_path}')


def shapefile(args):
    """
    Creates a shapefile from a CSV file
    :param args.csv_path: str, path to the CSV file (mandatory)
        contains a comment line with the EPSG code (optional)
        csv example:
            ```
            #epsg=4326
            x,y
            0,0
            ```
    :param args.shapefile_path: str, path to save the shapefile (mandatory)
    :param args.epsg: int, EPSG code for the coordinate system (optional)
    """
    shp.save_from_csv(args.csv_path, args.shapefile_path, epsg=args.epsg)
    print(f'* Saved to {args.shapefile_path}')


def crop(args):
    """
    Crop a geotiff file with a shapefile
    :param args.geotiff_path: str, path to the geotiff file (mandatory)
    :param args.shapefile_path: str, path to the shapefile (mandatory)
    :param args.save_path: str, path to save the cropped geotiff (optional)
    """
    save_path = args.save_path if args.save_path else args.geotiff_path.split('.')[0] + '_crop.tif' #todo better
    gdal = geo.open_geotiff(args.geotiff_path)
    cropped = geo.crop_from_shapefile(gdal, args.shapefile_path)
    geo.save_geotiff(cropped, save_path)
    print(f'* Saved to {save_path}')


# GENERAL COMMANDS

def silent_mode(args):
    if args.silent:
        sys.stdout = open(os.devnull, 'w')


def time_mode(args, t0):
    sys.stdout = sys.__stdout__
    t1 = time.time()
    if args.time:
        print(f'* Elapsed time: {t1 - t0:.2f} seconds')


# ARGUMENT PARSER SETUP

COMMANDS = {
    'ndsm': ndsm,
    'epsg': epsg,
    'reproject': reproject,
    'xyz': xyz,
    'cmap': cmap,
    'values': values,
    'shapefile': shapefile,
    'crop': crop,
}


def parser_setup():
    parser = argparse.ArgumentParser(description='PyDSM : DSM, DTM, nDSM & Ortophoto tools')
    parser.add_argument("--silent", action="store_true", help="Silent mode")
    parser.add_argument("--time", action="store_true", help="Displays time elapsed")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # ndsm command
    parser_ndsm = subparsers.add_parser("ndsm", help="Generate a nDSM from a DSM and DTM")
    parser_ndsm.add_argument("dsm_path", type=str, help="Path to the DSM")
    parser_ndsm.add_argument("dtm_path", type=str, help="Path to the DTM")
    parser_ndsm.add_argument("ndsm_path", type=str, help="Path to the output nDSM")
    parser_ndsm.add_argument("--correct-dtm", action="store_true", help="Correct extreme DTM values")
    parser_ndsm.add_argument("--capture-height", type=float, help="Height of the drone during the capture")

    # epsg command
    parser_epsg = subparsers.add_parser("epsg", help="Get the EPSG code of a file (GeoTIFF or Shapefile)")
    parser_epsg.add_argument("path", type=str, help="Path to the file")

    # reproject command
    parser_reproject = subparsers.add_parser("reproject", help="Reproject a file to a new EPSG code")
    parser_reproject.add_argument("path", type=str, help="Path to the geotiff file")
    parser_reproject.add_argument("--save-path", type=str, help="Path to save the reprojected file")
    parser_reproject.add_argument("--epsg", type=int, help="New EPSG code")

    # xyz command
    parser_xyz = subparsers.add_parser("xyz", help="Generate a XYZ file from a geotiff as a compressed numpy (.npz)")
    parser_xyz.add_argument("path", type=str, help="Path to the geotiff file")
    parser_xyz.add_argument("--save-path", type=str, help="Path to save the XYZ file")

    # cmap command
    parser_cmap = subparsers.add_parser("cmap", help="Generate a colormap png from a geotiff")
    parser_cmap.add_argument("path", type=str, help="Path to the geotiff file")
    parser_cmap.add_argument("--cmap", type=str, help="Colormap name (default: viridis)")
    parser_cmap.add_argument("--save-path", type=str, help="Path to save the colormap")

    # values command
    parser_values = subparsers.add_parser("values", help="Displays the values of a cropped image file (GeoTIFF or PNG)")
    parser_values.add_argument("path", type=str, help="Path to the image file")
    parser_values.add_argument("y", type=int, help="Y coordinate of the top left corner")
    parser_values.add_argument("x", type=int, help="X coordinate of the top left corner")
    parser_values.add_argument("h", type=int, help="height of the cropped image")
    parser_values.add_argument("w", type=int, help="width of the cropped image")
    parser_values.add_argument("--cmap", type=str, help="Colormap name (default: viridis)")
    parser_values.add_argument("--save-path", type=str, help="Path to save the values")
    parser_values.add_argument("--region", action="store_true", help="Overlay the region on the original image")
    parser_values.add_argument("--downscale", type=int, help="Downscale factor for the image")

    # create shapefile from csv
    parser_shp_create = subparsers.add_parser("shapefile", help="Create a shapefile from a CSV file")
    parser_shp_create.add_argument("csv_path", type=str, help="Path to the CSV file")
    parser_shp_create.add_argument("shapefile_path", type=str, help="Path to save the shapefile")
    parser_shp_create.add_argument("--epsg", type=int, help="EPSG code for the coordinate system")

    # crop geotiff with shapefile
    crop_parser = subparsers.add_parser("crop", help="Crop a geotiff file with a shapefile")
    crop_parser.add_argument("geotiff_path", type=str, help="Path to the geotiff file")
    crop_parser.add_argument("shapefile_path", type=str, help="Path to the shapefile")
    crop_parser.add_argument("--save-path", type=str, help="Path to save the cropped geotiff")

    return parser


def main():
    t0 = time.time()
    parser = parser_setup()
    args = parser.parse_args()
    silent_mode(args)
    COMMANDS[args.command](args)
    time_mode(args, t0)


if __name__ == "__main__":
    main()


#!/opt/anaconda3/envs/geo/bin/python

import webbrowser
import argparse
import time
import os
import sys

from skimage.draw import polygon
import imageio.v3 as iio
import numpy as np
import pandas as pd

import pydsm.geo as geo
import pydsm.nda as nda
import pydsm.shp as shp
import pydsm.utils as utils


# COMMANDS

def ndsm(args):
    """
    Computes the nDSM from a DSM and DTM
    :param args.dsm_path: str, path to the DSM (mandatory)
    :param args.dtm_path: str, path to the DTM (mandatory)
    :param args.ndsm_path: str, path to save the nDSM (optional)
    :param args.correct_dtm: bool, removes extreme DTM values (optional)
    :param args.capture_height: float, height of the drone during the capture (optional) (default: 60.0)
    :param args.resize: str, path to the orthophoto to resize the DSM and DTM (optional)
    :return: None (saves the nDSM to disk)
    """
    dsm = geo.open_geotiff(args.dsm_path)
    dtm = geo.open_geotiff(args.dtm_path)

    if args.resize:
        print(f'* Resizing DSM and DTM to the orthophoto shape')
        orthophoto = geo.open_geotiff(args.resize)
        shape_ortho = geo.get_shape(orthophoto)
        dsm = geo.resize_like(dsm, orthophoto) if geo.get_shape(dsm) != shape_ortho else dsm
        dtm = geo.resize_like(dtm, orthophoto) if geo.get_shape(dtm) != shape_ortho else dtm

    if geo.get_shape(dsm) != geo.get_shape(dtm):
        print(f'* Error: DSM and DTM have different shapes')
        print(f'  Consider resizing them to the orthophoto shape')
        return

    if args.correct_dtm:
        print(f'* Correcting DTM values')
        dtm = geo.correct_dtm(dtm)

    print(f'* Generating nDSM from {args.dsm_path} and {args.dtm_path}')
    capture_height = args.capture_height or 60.0
    ndsm = geo.to_ndsm(dsm, dtm, capture_height=capture_height)

    ndsm_path = args.ndsm_path or utils.append_file_to_path(utils.get_folder_path(args.dsm_path), 'ndsm.tif')
    geo.save_geotiff(ndsm, ndsm_path)
    print(f'* Saved to {ndsm_path}')


def epsg(args):
    """
    Displays the EPSG code of a file
    :param args.path: str, path to the file (mandatory)
    """
    ext = utils.get_extension(args.path)
    if ext == 'shp':
        epsg = shp.get_epsg(args.path)
        print(f'* Shapefile EPSG {epsg}')
    elif ext == 'tif':
        gdal = geo.open_geotiff(args.path)
        epsg = geo.get_epsg(gdal)
        print(f'* GeoTIFF EPSG {epsg}')
    else:
        epsg = None
        print('* Unknown file format')


def reproject(args):
    """
    Reprojects a geotiff file to a new EPSG code
    :param args.path: str, path to the geotiff file (mandatory)
    :param args.save_path: str, path to save the reprojected file (optional)
    :param args.epsg: int, new EPSG code (optional) (default: 4326)
    :return: None (saves the reprojected file to disk)
    """
    gdal = geo.open_geotiff(args.path)
    source_epsg = geo.get_epsg(gdal)
    print(f'* Reprojecting from EPSG:{source_epsg} to EPSG:{args.epsg}')
    reprojected = geo.reproject(gdal, args.epsg)

    save_path = args.save_path or f'{utils.remove_extension(args.path)}_{args.epsg}.tif'
    geo.save_geotiff(reprojected, save_path)
    print(f'* Saved to {save_path}')


def xyz(args):
    """
    Calculates the XYZ coordinates from a geotiff file (dtm, dsm, ndsm, etc.)
    Not recommended for large files. Use the geotiff directly instead.
    :param args.path: str, path to the geotiff file (mandatory)
    :param args.save_path: str, path to save the XYZ file (optional)
    :return: None (saves the XYZ file to disk as a compressed numpy file (.npz))
    """
    print(f'* Warning: The data generated by this command can be very large')
    print(f'* Consider querying the geotiff file directly instead')
    save_path = args.save_path or f'{utils.remove_extension(args.path)}.npz'
    gdal = geo.open_geotiff(args.path)
    epsg = geo.get_epsg(gdal)
    print(f'* Generating XYZ from EPSG {epsg}')
    xyz = geo.to_xyz(gdal)
    nda.write_numpy(save_path, data=xyz, metadata={'epsg': epsg})
    print(f'* Saved to {save_path}')


def cmap(args):
    """
    Converts a geotiff (dsm, dtm, ndsm) file to a colormap png
    :param args.path: str, path to the geotiff file (mandatory)
    :param args.cmap: str, colormap name (optional) (default: viridis)
    :param args.save_path: str, path to save the colormap (optional)
    :return: None (saves the colormap to disk)
    """
    cmap = args.cmap or 'viridis'
    save_path = args.save_path or f'{utils.remove_extension(args.path)}_{cmap}.png'
    gdal = geo.open_geotiff(args.path)
    print(f'* Generating {cmap} colormap from {args.path}')
    array = geo.to_ndarray(gdal)
    if np.min(array) == 0.0:
        array_cmap = nda.to_cmap(array, cmap=cmap)
        array_cmap = nda.to_uint8(array_cmap)
    else:
        array_cmap = nda.dsm_to_cmap(array, cmap=cmap)
    iio.imwrite(save_path, array_cmap)
    print(f'* Saved to {save_path}')


def values(args):
    """
    Overlays the pixel values over each pixel of a cropped portion of an image
    :param args.path: str, path to the image file (mandatory)
    :param args.y: int, Y coordinate of the top left corner (mandatory)
    :param args.x: int, X coordinate of the top left corner (mandatory)
    :param args.h: int, height of the cropped image (mandatory)
    :param args.w: int, width of the cropped image (mandatory)
    :param args.cmap: str, colormap name (optional) (default: viridis)
    :param args.save_path: str, path of the croped region (optional)
    :param args.region: bool, overlay the region over the original image (optional)
    :param args.downscale: int, downscale factor for the image for performance reasons (optional)
    """
    cmap = args.cmap or 'viridis'
    save_path = args.save_path or f'{utils.remove_extension(args.path)}_{cmap}_values.png'
    x, y, h, w = args.x, args.y, args.h, args.w
    x2, y2 = x + w, y + h
    gdal = geo.open_geotiff(args.path)
    array = geo.to_ndarray(gdal)

    if args.downscale:
        factor = args.downscale
        array = nda.downsample(array, factor)
        x, y, x2, y2 = x // factor, y // factor, x2 // factor, y2 // factor

    if args.region:
        print(f'* Generating {cmap} colormap of {args.path}')
        region_path = save_path.replace('_values.png', '_region.png')
        array_cmap = nda.to_cmap(array, cmap=cmap)
        array_cmap = nda.to_uint8(array_cmap)
        rr, cc = polygon([y, y, y2, y2], [x, x2, x2, x], shape=array.shape)
        array_cmap[rr, cc] = array_cmap[rr, cc] // 2
        iio.imwrite(region_path, array_cmap)
        print(f'* Saved to {region_path}')

    print(f'* Overlaying values of {args.path}')
    array = array[y:y2, x:x2]
    round_value = 0 if array.dtype == int else 3
    overlayed = nda.overlay_values(array, cmap=cmap, round_value=round_value)
    iio.imwrite(save_path, overlayed)
    print(f'* Saved to {save_path}')


def shapefile(args):
    """
    Creates a shapefile from a CSV file
    :param args.csv_path: str, path to the CSV file (mandatory)
        contains a comment line with the EPSG code (optional)
        For epsg=4326, the longitude is 'x' and the latitude is 'y'
        csv example:
            ```
            #epsg=4326
            x,y
            0,0
            ```
    :param args.shapefile_path: str, path to save the shapefile (mandatory)
    :param args.epsg: int, EPSG code for the coordinate system (optional)
    """
    shp_path = args.shapefile_path or f'{utils.remove_extension(args.csv_path)}.shp'
    shp.save_from_csv(args.csv_path, shp_path, epsg=args.epsg)
    print(f'* Saved to {args.shapefile_path}')


def crop(args):
    """
    Crop a geotiff file with a shapefile
    :param args.geotiff_path: str, path to the geotiff file (mandatory)
    :param args.shapefile_path: str, path to the shapefile (mandatory)
    :param args.save_path: str, path to save the cropped geotiff (optional)
    """
    path = utils.get_folder_path(args.geotiff_path)
    uuid = utils.remove_extension(utils.get_filename(args.shapefile_path))
    name = utils.remove_extension(utils.get_filename(args.geotiff_path))

    if args.save_path:
        if utils.get_extension(args.save_path) == '':
            save_path = utils.append_file_to_path(args.save_path, f'{uuid}_{name}.tif')
        else: save_path = args.save_path
    else: save_path = utils.append_file_to_path(path, f'{uuid}_{name}.tif')

    dilate = args.dilate or 15.0
    gdal = geo.open_geotiff(args.geotiff_path)
    cropped = geo.crop_from_shapefile(gdal, args.shapefile_path, dilate_size=dilate, mask_value=np.NaN)
    geo.save_geotiff(cropped, save_path)
    print(f'* Saved to {save_path}')


def zones(args):
    """
    Extracts zones surrounded by streets from a geotiff file
    Crops the geotiff file to the zones if --no-crop is not set and --crop-geotiff is not set

    :param args.geotiff_paths: str, path to the geotiff file (mandatory)
    :param args.geotiff_base_path: str, path to the folder that contains all the geotiff files (optional)
    :param args.save_directory: str, path to save the zones (shapefile, geotiff) (optional)
    :param args.no_crop: bool, do not crop the geotiff to the zones (optional)
    :param args.dilate: float, dilation factor around the zones (optional) (default: 15.0m)
    :param args.safe_zone: float, the zone is only kept if there is at lest X meters around (optional) (default: 20.0m)
    :param args.sample_size: int, sample size (number of seeds) to find the zones (optional) (default: 3 (3x3))
    :param args.translate_x: float, X translation (East to West) (optional)
    :param args.translate_y: float, Y translation (South to North) (optional)
    :param args.translate_file: str, path that contains the translation values (optional)
    """
    geotiff_paths = args.geotiff_paths
    if args.geotiff_base_path:
        geotiff_paths = [utils.append_file_to_path(args.geotiff_base_path, geotiff_path) for geotiff_path in geotiff_paths]

    save_folder = args.save_directory or utils.get_folder_path(geotiff_paths[0])
    sample_size = args.sample_size or 3
    safe_zone = args.safe_zone or 20.0
    dilate = args.dilate or 15.0
    x = args.translate_x or 0.0
    y = args.translate_y or 0.0

    if args.translate_file:
        df = pd.read_csv(args.translate_file)
        x = df['x'][0]
        y = df['y'][0]

    print(f'* Extracting zones from {geotiff_paths[0]}')
    uuids = geo.extract_zones(
        geotiff_paths[0], 
        save_folder, 
        sample_size=sample_size, 
        safe_zone=safe_zone
    )
    print(f'* Saved to {save_folder}')

    geotiff_paths = [] if args.no_crop else geotiff_paths
    for geotiff_path in geotiff_paths:
        print(f'* Cropping {geotiff_path}')
        geotiff_file = geo.open_geotiff(geotiff_path)

        if x or y:
            print(f'  Translating by {x}m X and {y}m Y')
            geotiff_file = geo.translation(geotiff_file, (x, y))

        name = utils.get_filename(geotiff_path)
        name = utils.remove_extension(name)

        for uuid in uuids:
            save_path = utils.append_file_to_path(save_folder, uuid)
            file_path = f'{save_path}_{name}.tif'
            croped_ortho = geo.crop_from_shapefile(geotiff_file, f'{save_path}.shp', dilate_size=dilate)
            geo.save_geotiff(croped_ortho, file_path)
            print(f'  Saved to {file_path}')


def info(args):
    """
    Displays information about a geotiff file

    :param args.path: str, path to the geotiff file (mandatory)
    """
    gdal = geo.open_geotiff(args.path)
    print(f'* Information about {args.path}')

    print(f'* Raster info:')
    print(f'  Shape: {geo.get_shape(gdal)}')

    dtype = geo.get_dtype(gdal)
    if dtype in utils.DTYPE_TO_NP.keys():
        print(f'  Dtype unit: {utils.DTYPE_TO_NP[dtype].__name__}')
    print(f'  Dtype number: {dtype}')

    print(f'* Geo info:')
    print(f'  EPSG:{geo.get_epsg(gdal)}')
    print(f'  Origin: {geo.get_origin(gdal)}')
    print(f'  Center: {geo.get_center(gdal)}')
    print(f'  Size: {geo.get_size(gdal)} m')
    print(f'  Scale: {geo.get_scales(gdal)[0]} m/px')


def resize(args):
    """
    Resize a geotiff file  
    `Warning` the resized geotiff will break the georeferencing

    :param args.geotiff_path: str, path to the geotiff file (mandatory)
    :param args.geotiff_like_path: str, path to the geotiff file to get the shape from (mandatory)
    :param args.save_path: str, path to save the resized (optional)
    """
    save_path = args.save_path or f'{utils.remove_extension(args.geotiff_path)}_resize.tif' 
    gdal = geo.open_geotiff(args.geotiff_path)
    gdal_like = geo.open_geotiff(args.geotiff_like_path)
    print(f'* Resizing from {geo.get_shape(gdal)} to {geo.get_shape(gdal_like)}')
    resized = geo.resize_like(gdal, gdal_like)
    geo.save_geotiff(resized, save_path)
    print(f'* Saved to {save_path}')


def translation(args):
    """
    2D translation of a geotiff file

    :param args.geotiff_path: str, path to the geotiff file (mandatory)
    :param args.x: float, X translation (mandatory)
    :param args.y: float, Y translation (mandatory)
    :param args.save_path: str, path to save the translated geotiff (optional)
    """
    save_path = args.save_path or f'{utils.remove_extension(args.geotiff_path)}_translate.tif'
    gdal = geo.open_geotiff(args.geotiff_path)

    if geo.get_epsg(gdal) == utils.CRS_GPS:
        print(f'* Warning: The translation in meters does not work with GPS coordinates')
        print(f'  Consider reprojecting the geotiff to a Cartesian coordinate system')
        return

    print(f'* Translating {args.geotiff_path} by {args.x}m X and {args.y}m Y')
    translated = geo.translation(gdal, (args.x, args.y))
    geo.save_geotiff(translated, save_path)
    print(f'* Saved to {save_path}')


def registration(args):
    """
    Register a geotiff file onto the osm map using a translation  
    The geotiff file is translated to the selected point on the map  

    :param args.geotiff_path: str, path to the geotiff file (mandatory)
    :param args.save_path: str, path to save the registered geotiff (optional)
    :param args.translate: bool, translate the geotiff to the selected point (optional)
    :param args.registration_path: str, path to save the translation values (optional)
    :param args.layer: str, layer of the map (osm, streets, satellite) (optional) (default: osm)
    """
    _unsilence()
    layer = args.layer or 'satellite'
    csv_path = args.registration_path or utils.append_file_to_path(utils.get_folder_path(args.geotiff_path), 'translate.csv')
    save_path = args.save_path or f'{utils.remove_extension(args.geotiff_path)}_register.tif'
    geotiff = geo.open_geotiff(args.geotiff_path)
    url = utils.epsgio_link_from_coord(geo.get_center(geotiff), geo.get_epsg(geotiff), layer=layer)

    print(f'* Registering {args.geotiff_path} onto the OSM map')
    print(f'  Please select a point on the map to register the geotiff')
    print(f'  Opening {url}')
    time.sleep(1)
    webbrowser.open(url)

    link = input('* Paste the link of the map here and press enter: ')
    osm_coord = utils.epsgio_link_to_coord(link)
    print(f'  The selected coordinate is {osm_coord}')

    print(f'* Please select the same point on the geotiff')
    geo_coord = geo.get_coordinate_on_click(geotiff)
    x = round(osm_coord[0] - geo_coord[0], 1)
    y = round(osm_coord[1] - geo_coord[1], 1)
    print(f'* Translation values: {x} {y} (x, y)')

    df = pd.DataFrame({'x': [x], 'y': [y]})
    df.to_csv(csv_path, index=False)
    print(f'* Saved to {csv_path}')

    if args.translate:
        print(f'* Translating {args.geotiff_path} by {x}m X and {y}m Y')
        translated = geo.translation(geotiff, (x, y))
        geo.save_geotiff(translated, save_path)
        print(f'* Saved to {save_path}')


# GENERAL COMMANDS

def _silence():
    sys.stdout = open(os.devnull, 'w')


def _unsilence():
    sys.stdout = sys.__stdout__


def silent_mode(args):
    if args.silent:
        _silence()


def time_mode(args, t0):
    _unsilence()
    t1 = time.time()
    if args.time:
        print(f'* Elapsed time: {t1 - t0:.2f} seconds')


# ARGUMENT PARSER SETUP

COMMANDS = {
    'ndsm': ndsm,
    'epsg': epsg,
    'reproject': reproject,
    'xyz': xyz,
    'cmap': cmap,
    'values': values,
    'shapefile': shapefile,
    'crop': crop,
    'zones': zones,
    'info': info,
    'resize': resize,
    'translation': translation,
    'registration': registration
}


def parser_setup():
    parser = argparse.ArgumentParser(description='PyDSM : DSM, DTM, nDSM & Ortophoto tools')
    parser.add_argument("--silent", action="store_true", help="Silent mode")
    parser.add_argument("--time", action="store_true", help="Displays time elapsed")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # ndsm command
    parser_ndsm = subparsers.add_parser("ndsm", help="Generate a nDSM from a DSM and DTM")
    parser_ndsm.add_argument("dsm_path", type=str, help="Path to the DSM (mandatory)")
    parser_ndsm.add_argument("dtm_path", type=str, help="Path to the DTM (mandatory)")
    parser_ndsm.add_argument("--ndsm_path", type=str, help="Path to the output nDSM")
    parser_ndsm.add_argument("--correct-dtm", action="store_true", help="Correct extreme DTM values")
    parser_ndsm.add_argument("--capture-height", type=float, help="Height of the drone during the capture (default: 60.0)")
    parser_ndsm.add_argument("--resize", type=str, help="Resize the DSM and DTM to the orthophoto shape")

    # epsg command
    parser_epsg = subparsers.add_parser("epsg", help="Get the EPSG code of a file (GeoTIFF or Shapefile)")
    parser_epsg.add_argument("path", type=str, help="Path to the file")

    # reproject command
    parser_reproject = subparsers.add_parser("reproject", help="Reproject a file to a new EPSG code")
    parser_reproject.add_argument("epsg", type=int, help="New EPSG code")
    parser_reproject.add_argument("path", type=str, help="Path to the geotiff file")
    parser_reproject.add_argument("--save-path", type=str, help="Path to save the reprojected file")

    # xyz command
    parser_xyz = subparsers.add_parser("xyz", help="Generate a XYZ file from a geotiff as a compressed numpy (.npz)")
    parser_xyz.add_argument("path", type=str, help="Path to the geotiff file")
    parser_xyz.add_argument("--save-path", type=str, help="Path to save the XYZ file")

    # cmap command
    parser_cmap = subparsers.add_parser("cmap", help="Generate a colormap png from a geotiff")
    parser_cmap.add_argument("path", type=str, help="Path to the geotiff file")
    parser_cmap.add_argument("--cmap", type=str, help="Colormap name (default: viridis)")
    parser_cmap.add_argument("--save-path", type=str, help="Path to save the colormap")

    # values command
    parser_values = subparsers.add_parser("values", help="Displays the values of a cropped image file (GeoTIFF or PNG)")
    parser_values.add_argument("path", type=str, help="Path to the image file")
    parser_values.add_argument("y", type=int, help="Y coordinate of the top left corner")
    parser_values.add_argument("x", type=int, help="X coordinate of the top left corner")
    parser_values.add_argument("h", type=int, help="height of the cropped image")
    parser_values.add_argument("w", type=int, help="width of the cropped image")
    parser_values.add_argument("--cmap", type=str, help="Colormap name (default: viridis)")
    parser_values.add_argument("--save-path", type=str, help="Path to save the values")
    parser_values.add_argument("--region", action="store_true", help="Overlay the region on the original image")
    parser_values.add_argument("--downscale", type=int, help="Downscale factor for the image")

    # create shapefile from csv
    parser_shp_create = subparsers.add_parser("shapefile", help="Create a shapefile from a CSV file")
    parser_shp_create.add_argument("csv_path", type=str, help="Path to the CSV file")
    parser_shp_create.add_argument("--shapefile_path", type=str, help="Path to save the shapefile")
    parser_shp_create.add_argument("--epsg", type=int, help="EPSG code for the coordinate system")

    # crop geotiff with shapefile
    crop_parser = subparsers.add_parser("crop", help="Crop a geotiff file with a shapefile")
    crop_parser.add_argument("geotiff_path", type=str, help="Path to the geotiff file")
    crop_parser.add_argument("shapefile_path", type=str, help="Path to the shapefile")
    crop_parser.add_argument("--dilate", type=float, help="Dilation factor around the shapefile (default: 15.0m)")
    crop_parser.add_argument("--save-path", type=str, help="Path to save the cropped geotiff")

    # zones command
    zones_parser = subparsers.add_parser("zones", help="Crops a geotiff into zones surrounded by streets")
    zones_parser.add_argument("geotiff_paths", nargs='+', help="Path to the geotiff files. The first one is used to find the zones.")
    zones_parser.add_argument("--geotiff-base-path", type=str, help="Path to the folder that contains all the geotiff files")
    zones_parser.add_argument("--save-directory", type=str, help="Path to save the zones (shapefile, geotiff)")
    zones_parser.add_argument("--no-crop", action="store_true", help="Do not crop the geotiff to the zones")
    zones_parser.add_argument("--dilate", type=float, help="Dilation factor around the zones (default: 15.0m)")
    zones_parser.add_argument("--safe-zone", type=float, help="The zone is only kept if there is at least X meters around it (default: 20.0m)")
    zones_parser.add_argument("--sample-size", type=int, help="Sample size (number of seeds) to find the zones (default: 3 (3x3))")
    zones_parser.add_argument("--translate-x", type=float, help="X translation (East to West)")
    zones_parser.add_argument("--translate-y", type=float, help="Y translation (South to North)")
    zones_parser.add_argument("--translate-file", type=str, help="Path that contains the translation values (Overrides translate-x and translate-y) (default: translate.csv in geotiff[0] dir)")

    # file info command
    file_info_parser = subparsers.add_parser("info", help="Display information about a geotiff")
    file_info_parser.add_argument("path", type=str, help="Path to the geotiff")

    # resize command
    resize_parser = subparsers.add_parser("resize", help="Resize a geotiff file")
    resize_parser.add_argument("geotiff_path", type=str, help="Path to the geotiff file to resize")
    resize_parser.add_argument("geotiff_like_path", type=str, help="Path to the geotiff file to get the shape from")
    resize_parser.add_argument("--save-path", type=str, help="Path to save the resized geotiff")

    # translation command
    translation_parser = subparsers.add_parser("translation", help="Translate a geotiff file")
    translation_parser.add_argument("geotiff_path", type=str, help="Path to the geotiff file to translate")
    translation_parser.add_argument("x", type=float, help="X translation (East to West)")
    translation_parser.add_argument("y", type=float, help="Y translation (South to North)")
    translation_parser.add_argument("--save-path", type=str, help="Path to save the translated geotiff")

    # registration command
    registration_parser = subparsers.add_parser("registration", help="Register a geotiff file onto the osm map")
    registration_parser.add_argument("geotiff_path", type=str, help="Path to the geotiff file to register")
    registration_parser.add_argument("--save-path", type=str, help="Path to save the registered geotiff")
    registration_parser.add_argument("--translate", action="store_true", help="Translate the geotiff to the selected point")
    registration_parser.add_argument("--registration-path", type=str, help="Path to save the translation values")
    registration_parser.add_argument("--layer", type=str, help="Layer of the map (osm, streets, satellite)")

    return parser


def main():
    t0 = time.time()
    parser = parser_setup()
    args = parser.parse_args()
    silent_mode(args)
    COMMANDS[args.command](args)
    time_mode(args, t0)


if __name__ == "__main__":
    main()

